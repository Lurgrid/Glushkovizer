\documentclass[12pt]{article}
\usepackage[french]{babel}
\usepackage{./cmpt/cmpt}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{float}
\usepackage{enumitem}
\usepackage{caption}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{automata, arrows}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{calc}

%--- begin document ------------------------------------------------------------

\title{Définition Formelle --- Glushkovizer}
\author{}
\date{}

\begin{document}

\maketitle

\begin{abstract}
    Ce document constitue la définition formelle des différents types de donnée
    utilisés tout au long de cette librairie. Dans un premier temps, nous nous
    concentrerons sur les expressions régulières et les fonctions définies sur
    celle-ci. Puis dans un second temps, nous nous intéresseront aux automates
    et à leur divers fonctions définies sur eux. Enfin pour finir, nous
    parlerons d'automates particuliers, ceux de Glushkov, nous aborderons leurs
    constructions, ainsi que leurs propriétés.
\end{abstract}

\newpage

\section{Les expressions régulières}

Dans cette section, nous parlerons d'expressions régulières (\textit{ER}). Nous
allons nous concentrer sur un type bien particulier d'expressions régulières
qui ne seront pas les expressions régulières que nous pouvons voir plus
quotidiennement dans le domaine de l'informatique, les expressions régulières
\textit{UNIX}. Mais plutôt une version plus simple de celles-ci.

\subsection{Définition}

Nous allons noter une expression régulière \(E(\Sigma)\), c'est-à-dire une
expression régulière où les symboles sont inclus dans l'ensemble \(\Sigma\).
Cette expression reconnait un langage qu'on pourra appeler \(L(E(\Sigma))\).
Nous pouvons définir une expression régulière récursivement de cette manière~:

\begin{align}
    E(\Sigma) & = \epsilon                            \\
    E(\Sigma) & = a \quad \text{avec}~ a \in \Sigma   \\
    E(\Sigma) & = F(\Sigma) + G(\Sigma)               \\
    E(\Sigma) & = F(\Sigma) \cdot G(\Sigma)           \\
    E(\Sigma) & = F(\Sigma)^*                         \\
    E(\Sigma) & = (F(\Sigma))\label{align:parenthese}
\end{align}

On notera que \(*\) est prioritaire sur \(\cdot\) qui est lui-même prioritaire
sur \(+\) et qu'ils sont tous deux associatif à gauche. On comprend donc
pourquoi l'équation~(\ref{align:parenthese}) existe, elle est là pour des
raisons de priorité. Il est alors évidant de calculer les diverses fonctions
sur celle-ci, c'est pour cela qu'on ne précisera pas son
calcul\label{text:parenthese}. On peut définir chaque équation comme ceci~:

\vphantom{}

\begin{itemize}
    \item[\textbullet] \textbf{\(E(\Sigma) = \epsilon\) (epsilon)~:}
        Représente le mot vide, de ce fait un mot de longueur zéro. Il en vient
        que~:

        \begin{align}
            L(E(\Sigma)) & = \{\epsilon\}
        \end{align}

        Il peut être parfois représenté par `\$'.

        \vphantom{}

    \item[\textbullet] \textbf{\(E(\Sigma) = a\)~:} Représente un symbole
        présent dans l'ensemble \(\Sigma\). Il en vient que~:

        \begin{align}
            L(E(\Sigma)) & = \{a\}
        \end{align}

        \vphantom{}

    \item[\textbullet] \textbf{\(F(\Sigma) + G(\Sigma)\)~:} Représente l'union
        des deux expressions régulières \(F(\Sigma)\) et \(G(\Sigma)\). Il en
        vient que~:

        \begin{align}
            L(F(\Sigma) + G(\Sigma)) & = L(F(\Sigma)) \cup L(G(\Sigma))
        \end{align}

        Par abus de langage, on peut aussi dire \(F(\Sigma)\) `ou' \(G(\Sigma)\) pour
        représenter cette union.

        \vphantom{}

    \item[\textbullet] \textbf{\(E(\Sigma) = F(\Sigma) \cdot G(\Sigma)\)~:}
        Représente la concaténation deux deux des deux expressions régulières
        \(F(\Sigma)\) et \(G(\Sigma)\). Il en vient que~:

        \begin{align}
            L(E(\Sigma)) & = \{u \cdot v ~|~ u \in L(F(\Sigma)) \land v \in L(G(\Sigma)) \}
        \end{align}

        \vphantom{}

    \item[\textbullet] \textbf{\(E(\Sigma) = F(\Sigma)^* \)~:} Représente la
        répétition infinie de \(F(\Sigma)\), cette répétition incluant, aucune
        répétition et donc le mot vide. Il en vient que~:

        \begin{align}
            L(E(\Sigma)) & = \{u^* ~|~ u \in L(F(\Sigma))\}
        \end{align}
\end{itemize}

\subsubsection*{Exemple~:}

On comprendra ainsi que l'expression \(E(\mathbb{A}) = a+c \cdot d\) avec
\(\mathbb{A} = \{a, b, c, d\}\), dénote le langage \(L(E(\mathbb{A})) = \{a,
cd\}\). Car on peut représenter \(E(\mathbb{A})\) comme ceci~:

\begin{figure}[H]
    \centering
    \captionsetup{type=figure,justification=centering}
    \begin{tikzpicture}[
            mycircle/.style={
                    draw,
                    circle,
                    minimum height=.75cm,
                    minimum width=.75cm
                },
            mysquare/.style={
                    draw,
                    rectangle,
                    minimum height=.5cm,
                    minimum width=.5cm,
                }
        ]
        \node[mysquare] (plus) {+}
        child {node[mycircle] (a) {a}}
        child {
                node[mysquare] (point) {.}
                child {node[mycircle] (c) {c}}
                child {node[mycircle] (d) {d}}
            };

        \node[right=3mm of d] {\(\{d\}\)};
        \node[left=3mm of c] {\(\{c\}\)};
        \node[right=3mm of point] {\(\{cd\}\)};
        \node[left=3mm of a] {\(\{a\}\)};
        \node[above=3mm of plus] {\(\{a, cd\}\)};
    \end{tikzpicture}
    \caption{
        Représentation de l'expression régulière à l'aide d'un arbre syntaxique
    }\label{fig:arbre_syn}
\end{figure}

Comme on peut voir sur la figure~\ref{fig:arbre_syn} grâce à cette
représentation, on peut calculer simplement le langage reconnu par l'expression
régulière (ici représenter par les ensemble à côté de chaque arbre).

\vphantom{}

On comprendra aussi que l'expression \(E'(\mathbb{A}) = \epsilon + b^* \cdot
a\), dénote le langage \(L(E'(\mathbb{A})) = \{\epsilon, b^* \cdot a\}
\Leftrightarrow \{\epsilon, a, b^+\}\).

\begin{figure}[H]
    \centering
    \captionsetup{type=figure,justification=centering}
    \begin{tikzpicture}[
            mycircle/.style={
                    draw,
                    circle,
                    minimum height=.75cm,
                    minimum width=.75cm
                },
            mysquare/.style={
                    draw,
                    rectangle,
                    minimum height=.5cm,
                    minimum width=.5cm,
                }
        ]
        \node[mysquare] (plus) {+}
        child {node[mycircle] (epsilon) {\(\epsilon\)}}
        child {
                node[mysquare] (point) {\(\cdot \)}
                child {
                        node[mysquare] (etoile) {*}
                        child {
                                node[mycircle] (b) {b}
                            }
                    }
                child {node[mycircle] (a) {a}}
            };

        \node[right=3mm of a] {\(\{a\}\)};
        \node[left=3mm of b] {\(\{b\}\)};
        \node[left=3mm of etoile] {\(\{b^*\}\)};
        \node[right=3mm of point] {\(\{b^* \cdot a\}\)};
        \node[left=3mm of epsilon] {\(\{\epsilon\}\)};
        \node[above=3mm of plus] {\(\{\epsilon, b^* \cdot a\}\)};
    \end{tikzpicture}
    \caption{
        Représentation de l'expression régulière à l'aide d'un arbre syntaxique
    }
\end{figure}

\subsection{Fonction sur les \textit{ER}}

\textbullet~Une des fonctions les plus importantes sur les expressions régulières
est \(flnf\) permettant de calculer \(FLNF(E(\Sigma))\) qui est un tuple défini
comme ceci~:

\vphantom{}

\begin{center}
    \(FLNF(E(\Sigma)) = (F, L, \Theta, \delta)\)

    \begin{itemize}
        \item[\textbullet] \(F \subseteq \Sigma\)~: Ensemble des premiers
            symboles de l'expression régulière

            \vphantom{}

        \item[\textbullet] \(L \subseteq \Sigma\)~: Ensemble des derniers
            symboles de l'expression régulière

            \vphantom{}

        \item[\textbullet] \(\Theta\) =
            \(
            \begin{cases}
                \epsilon,   & \text{si}~ \epsilon \in L(E(\Sigma)) \\
                \varnothing & \text{sinon}
            \end{cases}
            \)

            \vphantom{}

        \item[\textbullet] \(\delta\)~: \(\Sigma \to S\) avec \(S \subseteq
            \Sigma\). \\
            Fonction renvoyant les symboles suivant du symbole passer argument.
    \end{itemize}
\end{center}

La fonction \(flnf\) a donc comme signature~:

\begin{align}
    flnf: E(\Sigma) \to FLNF(E(\Sigma))
\end{align}

Et peut-être calculée de cette manière~:

\begin{align}
    flnf(\epsilon) & = (\varnothing, \varnothing, \epsilon, \delta) ~|~ \delta(a) = \varnothing, a \in \Sigma \\
    \vphantom{} \notag                                                                                        \\
    flnf(a)        & = (\{a\}, \{a\}, \varnothing, \delta) ~|~ \delta(a) = \varnothing, a
    \in \Sigma
\end{align}

\begin{gather}
    flnf(E(\Sigma) + G(\Sigma)) = (F \cup F', L \cup L', \Theta \cup \Theta', \delta'')~ \text{avec} \\
    \delta''(a) = \delta(a) \cup \delta'(a) ~|~ \forall a \in \Sigma \notag \\
    (F, L, \Theta, \delta) = flnf(E(\Sigma)) \land (F', L', \Theta', \delta') = flnf(G(\Sigma)) \notag
\end{gather}

\begin{gather}
    flnf(E(\Sigma) \cdot G(\Sigma)) = (F'', L'', \Theta \cap \Theta', \delta'')~ \text{avec} \\
    F'' = F \cup F' \cdot \Theta \notag \\
    L'' = L' \cup L \cdot \Theta' \notag \\
    \delta''(a) = \begin{cases} \delta(a) \cup \delta'(a) \cup F', & \text{si}~ a \in L \\ \delta(a) \cup \delta'(a) & \text{sinon}\end{cases} ~|~ \forall a \in \Sigma\notag \\
    (F, L, \Theta, \delta) = flnf(E(\Sigma)) \land (F', L', \Theta', \delta') = flnf(G(\Sigma)) \notag
\end{gather}

\begin{gather}
    flnf(E(\Sigma)^*) = (F, L, \epsilon, \delta')~ \text{avec} \\
    \delta'(a) = \begin{cases} \delta(a) \cup F, & \text{si}~ a \in L \\ \delta(a) & \text{sinon}\end{cases} ~|~ \forall a \in \Sigma\notag \\
    (F, L, \Theta, \delta) = flnf(E(\Sigma)) \notag
\end{gather}

\subsubsection*{Exemple~:}

Prenons par exemple l'expression régulière suivante \(E(\mathbb{A}) = a \cdot b
+ c \cdot d\), avec \(\mathbb{A} = \{a, b, c, d\}\). Toujours à l'aide d'un
arbre syntaxique, on peut calculer ce que \(flnf(E(\mathbb{A}))\) donnerait.

\begin{figure}[H]
    \centering
    \captionsetup{type=figure,justification=centering}
    \begin{tikzpicture}[
            level 1/.style={
                    sibling distance=6cm
                },
            level 2/.style={
                    sibling distance=3cm
                },
            mycircle/.style={
                    draw,
                    circle,
                    minimum height=.75cm,
                    minimum width=.75cm
                },
            mysquare/.style={
                    draw,
                    rectangle,
                    minimum height=.5cm,
                    minimum width=.5cm,
                }
        ]
        \node[mycircle] (plus) {+}
        child {
                node[mysquare] (point) {\(\cdot\)}
                child {node[mycircle] (a) {a} }
                child {node[mycircle] (b) {b} }
            }
        child {
                node[mysquare] (point2) {\(\cdot\)}
                child {node[mycircle] (c) {c} }
                child {node[mycircle] (d) {d}}
            };

        \node[below=3mm of a] {\((\{a\}, \{a\}, \varnothing, \varnothing)\)};
        \node[below=3mm of b] {\((\{b\}, \{b\}, \varnothing, \varnothing)\)};
        \node[below=3mm of c] {\((\{c\}, \{c\}, \varnothing, \varnothing)\)};
        \node[below=3mm of d] {\((\{d\}, \{d\}, \varnothing, \varnothing)\)};

        \node[left=3mm of point] {\((\{a\}, \{b\}, \varnothing, \{(a, b)\})\)};
        \node[right=3mm of point2] {\((\{c\}, \{d\}, \varnothing, \{(c, d)\})\)};

        \node[above=3mm of plus] {\((\{a, c\}, \{b, d\}, \varnothing, \{(a, b),(c, d)\})\)};
    \end{tikzpicture}
    \caption{
        Représentation de l'expression régulière à l'aide d'un arbre syntaxique.
        Pour des raisons de compréhension \(\delta\) est représenté à l'aide
        d'un ensemble de couple.
    }
\end{figure}

Il advient que \(flnf(E(\mathbb{A})) = \{\{a, c\}, \{b, d\}, \varnothing,
\delta\}\) avec \(\delta\) qui est défini comme ceci~:

\begin{align*}
    \delta(a) & = \{b\}       \\
    \delta(b) & = \varnothing \\
    \delta(c) & = \{d\}       \\
    \delta(d) & = \varnothing
\end{align*}

Un autre exemple pourrait être \(E'(\mathbb{A}) = (a + b) \cdot c^*\), avec cet
exemple, on voit l'utilité de la parenthèse, car sans elle la concaténation
aurait été sur \(b \cdot c^*\) et comme dit précédemment
(\ref{text:parenthese}) son calcul reste le même que si c'était une union.

\begin{figure}[H]
    \centering
    \captionsetup{type=figure,justification=centering}
    \begin{tikzpicture}[
            level 1/.style={
                    sibling distance=6cm
                },
            level 2/.style={
                    sibling distance=3cm
                },
            mycircle/.style={
                    draw,
                    circle,
                    minimum height=.75cm,
                    minimum width=.75cm
                },
            mysquare/.style={
                    draw,
                    rectangle,
                    minimum height=.5cm,
                    minimum width=.5cm,
                }
        ]
        \node[mycircle] (point) {\(\cdot\)}
        child {
                node[mysquare] (plus) {\(+\)}
                child {node[mycircle] (a) {a} }
                child {node[mycircle] (b) {b} }
            }
        child {
                node[mysquare] (etoile) {\(*\)}
                child {node[mycircle] (c) {c} }
            };

        \node[below=3mm of a] {\((\{a\}, \{a\}, \varnothing, \varnothing)\)};
        \node[below=3mm of b] {\((\{b\}, \{b\}, \varnothing, \varnothing)\)};
        \node[below=3mm of c] {\((\{c\}, \{c\}, \varnothing, \varnothing)\)};

        \node[left=3mm of plus] {\((\{a, b\}, \{a, b\}, \varnothing, \varnothing)\)};
        \node[right=3mm of etoile] {\((\{c\}, \{c\}, \epsilon, \{(c, c)\})\)};

        \node[above=3mm of point] {\((\{a, b\}, \{a, b, c\}, \varnothing, \{(a, c), (b, c), (c, c)\})\)};
    \end{tikzpicture}
    \caption{
        Représentation de l'expression régulière à l'aide d'un arbre syntaxique.
        Pour des raisons de compréhension \(\delta\) est représenté à l'aide
        d'un ensemble de couple.
    }
\end{figure}

Ce qui fait que \(flnf(E'(\mathbb{A})) = (\{a, b\}, \{a, b, c\}, \varnothing,
\delta')\) avec \(\delta'\) qui est défini comme décrit après~:

\begin{align*}
    \delta(a) & = \{c\}       \\
    \delta(b) & = \{c\}       \\
    \delta(c) & = \{c\}       \\
    \delta(d) & = \varnothing
\end{align*}

\textbullet~Une autre fonction qui s'applique sur les expressions régulières
est \(linearization\), elle peut paraitre inutile, mais elle nous servira dans
la Section~\ref{sec:glushkov}. Sa signature est~:

\begin{gather*}
    linearization: E(\Sigma) \times \mathbb{N} \to (E(\Sigma^{\mathbb{N}}), \mathbb{N}) \\
    \text{avec } \Sigma^{\mathbb{N}} = (\Sigma, \mathbb{N}) \land \forall ((a, b), (c, d)) \in (\Sigma^{\mathbb{N}})^2 ~|~ b = d \Rightarrow a = c \Rightarrow (a, b) = (c, d)
\end{gather*}

Elle peut être définie récursivement de cette manière~:

\begin{gather}
    linearization(\epsilon, n) = (\epsilon, n) \\
    linearization(a, n) = ((a, n), n + 1) \\
    linearization(E(\Sigma) + F(\Sigma), n) = (E' + F', n'') \quad \text{avec } \\
    (E', n') \leftarrow linearization(E(\Sigma), n) \notag \\
    (F', n'') \leftarrow linearization(F(\Sigma), n') \notag \\
    linearization(E(\Sigma) \cdot F(\Sigma), n) = (E' \cdot F', n'') \quad
    \text{avec } \\
    (E', n') \leftarrow linearization(E(\Sigma), n) \notag \\
    (F', n'') \leftarrow linearization(F(\Sigma), n') \notag \\
    linearization(E(\Sigma)^*, n) = (E'^*, n') \quad \text{avec} \\
    (E', n') \leftarrow linearization(E(\Sigma), n) \notag
\end{gather}

Avec cette définition, on peut voir que tous les deuxièmes éléments du couple
des symboles du résultat \(E'\) avec \(linearization(E(\Sigma), n) = (E', m)\),
seront supérieurs ou égaux à \(n\) et inférieur strict à \(m\).

\subsubsection*{Exemple~:}

Si on reprend cette expression régulière \(E(\mathbb{A}) = \epsilon + b^* \cdot
a\), avec \(\mathbb{A} = \{a, b, c, d\}\).

\begin{figure}[H]
    \centering
    \captionsetup{type=figure,justification=centering}
    \begin{tikzpicture}[
            mycircle/.style={
                    draw,
                    rectangle,
                    rounded corners=.375cm,
                    minimum height=.75cm,
                    minimum width=.75cm
                },
            mysquare/.style={
                    draw,
                    rectangle,
                    minimum height=.5cm,
                    minimum width=.5cm,
                }
        ]
        \node[mysquare] (1) {+}
        child {node[mycircle] {\(\epsilon\)}}
        child {
                node[mysquare] {\(\cdot \)}
                child {
                        node[mysquare] {*}
                        child {
                                node[mycircle] {b}
                            }
                    }
                child {node[mycircle] {a}}
            };
        \node[mysquare, right=7cm of 1] (2) {+}
        child {node[mycircle] {\(\epsilon\)}}
        child {
                node[mysquare] {\(\cdot \)}
                child {
                        node[mysquare] {*}
                        child {
                                node[mycircle] {(b, 1)}
                            }
                    }
                child {node[mycircle] {(a, 2)}}
            };

        \draw[line width=.5mm, -{Stealth[length=5mm, open]}] ($(1.east) + (1.5cm, -2cm)$) -- node[midway, above=2mm] {\(linearization\)} ($(2.west) + (-1.5cm, -2cm)$);
    \end{tikzpicture}
    \caption{
        Représentation à l'aide d'un arbre syntaxique de l'expression régulière
        une fois après avoir fait appel à \(linearization\) sur elle.
    }
\end{figure}

\subsection{Conclusion}

On saisit aisément que ces expressions ont beau être simple (peu d'opération
comparé aux expressions régulières d'\textit{UNIX}). Elles n'en sont rien pas
complètes, on peut voir qu'elles permettent de décrire des langages très
complexes et en quantité infinie. Malheureusement, il est difficile de savoir
si un mot est reconnu par une expression régulière simplement. Par exemple
est-ce-que le mot \(eipipipipipip\) est reconnu par cette expression \(((((o
\cdot \epsilon)+(\epsilon \cdot e))+((g\cdot \epsilon) \cdot \epsilon^*)) \cdot
((\epsilon \cdot i)\cdot (p+\epsilon))^*)\)~? La réponse est oui. C'est pour
cela qu'il serait peut-être intéressant d'utiliser une autre structure de
donnée pour reconnaitre des mots, comme les automates que nous allons voir
maintenant.

\section{Les automates}

Dans cette partie, nous parlerons des automates et plus particulièrement, nous
allons parler des automates sans \(\epsilon\) transition. Pour autant les
automates que nous verrons sont tout aussi bons que ceux avec \(\epsilon\)
transition.

\subsection{Définition}

Comme dit précédemment un automate est un objet mathématique reconnaissant un
langage, on notera \(M(\Sigma, \eta)\) l'automate qui a pour transition des
valeurs dans \(\Sigma\) et des valeurs `d'état' dans \(\eta\). On écrira donc
\(L(M(\Sigma, \eta))\) pour désigner le langage qu'il reconnait. Un automate
est tuple qu'on peut écrire de cette forme \(M(\Sigma, \eta) = (Q, I, F,
\delta)\) avec~:

\begin{align}
    Q        & \subseteq \eta \quad \text{L'ensemble des états qui constitue l'automate} \\
    I        & \subseteq Q \quad \text{L'ensemble des états initiaux}                    \\
    F        & \subseteq Q \quad \text{L'ensemble des états finaux}                      \\
    \delta:~ & Q \times \Sigma \to 2^Q \quad \text{La fonction de transition}
\end{align}

Un automate peut se représenter à l'aide d'un graphe particulier, Par exemple
si on veut représenter \(M(\Sigma, \eta) = (\{q_1, q_2, q_3, q_4, q_5\},
\{q_1\},\{q_2, q_3\}, \delta)\) avec \(\Sigma = \{0, 1\}\), \(\eta = \{q_1,
q_2, q_3, q4_, q_5\}\) et \(\delta\) défini comme ceci~:

\begin{align*}
    \delta(q_1, 0) & = \{q_2\}     \\
    \delta(q_1, 1) & = \{q_4\}     \\
    \delta(q_2, 0) & = \varnothing \\
    \delta(q_2, 1) & = \varnothing \\
    \delta(q_3, 0) & = \{q_3\}     \\
    \delta(q_3, 1) & = \{q_4\}     \\
    \delta(q_4, 0) & = \{q_5\}     \\
    \delta(q_4, 1) & = \varnothing \\
    \delta(q_5, 0) & = \{q_4\}     \\
    \delta(q_5, 0) & = \{q_5\}     \\
\end{align*}

\begin{figure}[H]
    \centering
    \captionsetup{type=figure,justification=centering}
    \begin{tikzpicture}
        \tikzset{
            ->,
            >=stealth',
            node distance=3cm,
            every state/.style={thick},
            initial text=$ $,
        }
        \node[state, initial] (q1) {$q_1$};
        \node[state, accepting, right of=q1] (q2) {$q_2$};
        \node[state, above of=q2] (q4) {$q_4$};
        \node[state, accepting, right of=q2] (q3) {$q_3$};
        \node[state, right of=q4] (q5) {$q_5$};

        \draw   (q1) edge[above] node{1} (q4)
        (q1) edge[below] node{0} (q2)
        (q4) edge[bend right, below] node{1} (q3)
        (q4) edge[above] node{0} (q5)
        (q3) edge[above] node{1} (q4)
        (q3) edge[loop right] node{0} (q3)
        (q5) edge[bend right, above] node{0} (q4)
        (q5) edge[loop right] node{1} (q5);
    \end{tikzpicture}
    \caption{
        Exemple de représentation graphique d'un automate.
    }\label{fig:automata}
\end{figure}

Dans la figure~\ref{fig:automata}, on peut voir que les états initiaux (ici que
\(q_1\)) ont une petite flèche qui pointe sur lui et que les états finaux ont
un double contour. Et que les transitions sont symbolisées par des flèches
entre les états et que ces flèches sont labellisées.

\vphantom{}

On parlera de l'inverse de l'automate \(M(\Sigma, \eta)\) noté
\(\overline{M(\Sigma, \eta)}\) qui peut être défini de cette façon~:

\begin{gather}
    \overline{M(\Sigma, \eta)} = (Q, F, I, \delta') \quad \text{avec} \\
    M(\Sigma, \eta) = (Q, I, F, \delta) \notag \\
    \forall (p, q) \in Q^2 ~|~ q \in \delta(p, a) \Rightarrow p \in \delta'(q, a) \notag
\end{gather}

Donc si on veut représenter l'inverse de l'automate représenté dans la
figure~\ref{fig:automata}, ça nous donnerait ceci~:

\begin{figure}[H]
    \centering
    \captionsetup{type=figure,justification=centering}
    \begin{tikzpicture}
        \tikzset{
            ->,
            >=stealth',
            node distance=3cm,
            every state/.style={thick},
            initial text=$ $,
        }
        \node[state, accepting] (q1) {$q_1$};
        \node[state, initial below, right of=q1] (q2) {$q_2$};
        \node[state, above of=q2] (q4) {$q_4$};
        \node[state, initial below, right of=q2] (q3) {$q_3$};
        \node[state, right of=q4] (q5) {$q_5$};

        \draw   (q4) edge[above] node{1} (q1)
        (q2) edge[below] node{0} (q1)
        (q3) edge[bend left, below] node{1} (q4)
        (q5) edge[above] node{0} (q4)
        (q4) edge[above] node{1} (q3)
        (q3) edge[loop right] node{0} (q3)
        (q4) edge[bend left, above] node{0} (q5)
        (q5) edge[loop right] node{1} (q5);
    \end{tikzpicture}
    \caption{
        Exemple de représentation graphique de l'inverse de l'automate de la
        figure~\ref{fig:automata}.
    }\label{fig:automata_invserse}
\end{figure}

On voit bien que l'apparence de l'automate ne change pas les transitions sont
juste inversées et les états initiaux sont devenus finaux et inversement.

\vphantom{}

On peut aussi étendre la fonction de transition \(\delta\) de manière qu'elle
ait comme signature~:

\[
    \delta_w: Q \times \Sigma^* \to 2^Q
\]

En la définissant récursivement de telle sorte~:

\begin{align}
    \delta_w(q, \epsilon) & = \{q\}                                                                       \\
    \delta_w(q, a.w)      & = \bigcup_{q'}^{\delta(q, a)} \delta_w(q', w) \quad \text{avec}~ a \in \Sigma
\end{align}

\subsubsection*{Exemple~:}

Voici donc quelques exemples de ce que ça nous donnerait si on reprend
l'automate utilisé pour la représentation graphique
(figure~\ref{fig:automata})~:

\begin{gather}
    \delta_w(q_1, 00) = \varnothing \\
    \delta_w(q_1, 11) = \{q_3\} \\
    \delta_w(q_1, \varnothing) = \{q_1\} \\
    \delta_w(q_1, 10111\dots) = \{q_5\}
\end{gather}

\subsubsection*{Propriétés~:}

Un automate est dit \textit{standard} à l'instant où il ne possède qu'un seul
état initial non ré-entrant, aussi défini comme ceci~:

\begin{gather}
    M(\Sigma, \eta) = (Q, \{i\}, F, \delta) \quad \text{avec} \\
    \forall p \in Q, \forall a \in \Sigma ~|~ i \notin \delta(p, a) \notag
\end{gather}

Un automate est identifié \textit{homogène} quand pour tous les états les
transition allant vers cet état ont même valeur. En d'autre terme quand il
respecte cette propriété~:

\begin{gather}
    M(\Sigma, \eta) = (Q, I, F, \delta) \quad \text{avec} \\
    \forall q \in Q, \exists! a \in \Sigma ~|~ q \in \delta(p, a) \notag
\end{gather}

Un automate est qualifié d'\textit{accessible} lorsqu'en partant des initiaux,
on peut arriver sur tous les états qui le composent. C'est-à-dire qu'il valide
cette condition~:

\begin{gather}
    M(\Sigma, \eta) = (Q, I, F, \delta) \quad \text{avec} \\
    \forall p \in Q, \exists w \in \Sigma^* ~|~ p \in \bigcup_{i}^{I} \delta_w(i, w) \notag
\end{gather}

Un automate est considéré comme \textit{coaccessible} au moment où l'inverse de
cette automate est accessible. Ceci veut dire qu'il atteste de cette
particularité~:

\begin{gather}
    M(\Sigma, \eta) = (Q, I, F, \delta) \quad \text{avec} \\
    accessible(\overline{M(\Sigma, \eta)}) \notag
\end{gather}

Donc l'automate représenté sur la figure~\ref{fig:automata} est standard, non
homogène, accessible et coaccessible. Car il possède bien un unique état
initial (\(q_1\)), mais malheureusement \(q_3\), \(q_4\) et \(q_5\) ne respecte
pas la propriété pour être homogène, parce qu'ils ont des transitions allant
vers eux avec des valeurs différentes. De plus tous ses états sont par
accessible depuis l'état initial et son inverse est, lui-même aussi,
accessible.

\vphantom{}

Les automates pouvant être représentés à l'aide de graphe, on peut étendre les
propriétés sur les graphes aux automates. Par exemple, on pourra parler des
composantes fortement connexes d'un automate. Autrement dit en partant de
n'importe quel état, on peut arriver à tous les autres états. Ainsi ça veut
dire qu'un automate fortement connexe vérifierait ceci~:

\begin{gather}
    M(\Sigma, \eta) = (Q, I, F, \delta) \quad \text{avec} \\
    \forall (p, q) \in Q^2, \exists w \in \Sigma^* ~|~ q \in \delta_w(p, w) \notag
\end{gather}

\subsection{Fonction sur les automates}

Une des fonctions la plus importante sur les automates est \(accept\) qui test
si le mot est reconnu par l'automate. C'est-à-dire que si on prend le chemin
décrit par le mot donner en argument, on arrive sur un ou plusieurs états
finaux. Elle a alors pour signature~:

\[
    accept: M(\Sigma, \eta) \times \Sigma^* \to \mathbb{B}
\]

Elle peut être définie simplement comme ceci~:

\begin{align}
    accept(M(\Sigma, \eta), w) = \exists q \in \bigcup_{p}^I \delta_w(p, w) ~|~ q \in F
\end{align}

\subsection{Conclusion}

Comme nous venons de voir les automates sont des outils puissants pour
reconnaitre des mots d'un langage. L'un de leur plus grande force est leur
simplicité, toutes les opérations sur les automates peuvent donc être
automatisé. Ce qui fait que cet objet est très intéressant dans le monde de
l'\textit{informatique}. En revanche l'un de ses points faibles est sa
représentation, il est difficile de représenter des très gros automates
contrairement aux expressions régulières. Il serait alors intéressant de
pouvoir convertir une expression régulière en automate. C'est ce que nous
allons voir dans la prochaine section.

\section{Les automates de Glushkov}\label{sec:glushkov}

Le terme `automates de Glushkov' est un abus de langage, faisant référence aux
automates que l'algorithme de transformation d'expression régulière en
automate, appelé algorithme de Glushkov produit. Son nom vient de
l'informaticien soviétique \textit{Victor Glushkov} qui est son créateur.

\subsection{Définition}

Nous appliquerons cet algorithme à l'aide la fonction \(glushkov\) qui a donc
pour signature~:

\[
    glushkov: E(\Sigma) \to M(\Sigma, \mathbb{N})
\]

Et a ainsi, on peut définir cette fonction de cette façon~:

\begin{gather}
    glushkov     (E(\Sigma)) = (Q, \{0\}, F, \delta) \quad \text{avec} \\
    \begin{align*}
        Q                                             & \leftarrow \{n ~|~ n \in \mathbb{N} \land 0 \leq n < m\}                                                                                            \\
        F                                             & \leftarrow \begin{cases} \{n ~|~ (a, n) \in Last\} \cup \{0\}, & \text{si } Null = \epsilon \\ \{n ~|~ (a, n) \in Last\} & \text{sinon} \end{cases} \\
        \forall q                    \in \delta(p, a) & ~|~ \begin{cases} (a, q) \in First, & \text{si } p = 0 \\ (a, q) \in Follow((b, p)) & \text{sinon} \end{cases}                                      \\
        (E', m)                                       & \leftarrow linearization(E(\Sigma), 1)                                                                                                              \\
        (First, Last, Null, Follow)                   & \leftarrow flnl(E')
    \end{align*}
\end{gather}

\subsubsection*{Exemple~:}

Vu qu'un dessin vaut toujours mieux que mile mots, voici un exemple de
l'automate résultant de la transformation de cette expression \(E(\mathbb{A}) =
(a+b) \cdot a^* \cdot b^* \cdot (a+b)^*\).

\begin{figure}[H]
    \centering
    \captionsetup{type=figure,justification=centering}
    \begin{tikzpicture}
        \tikzset{
            ->,
            >=stealth',
            node distance=2.25cm,
            every state/.style={thick},
            initial text=\( \),
        }
        \node[state, initial] (0) {\(0\)};
        \node[state, accepting, right of=0, below of=0] (1) {\(1\)};
        \node[state, accepting, right of=0, above of=0] (2) {\(2\)};
        \node[state, accepting, right of=2, below of=2] (3) {\(3\)};
        \node[state, accepting, right of=3] (4) {\(4\)};
        \node[state, accepting, right of=4, above of=4] (5) {\(5\)};
        \node[state, accepting, right of=5] (6) {\(6\)};

        \draw   (0) edge[below] node{a} (1)
        (0) edge[above] node{b} (2)
        (1) edge[below] node{a} (3)
        (2) edge[above] node{a} (3)
        (1) edge[bend right=1.5cm, below] node{b} (6)
        (2) edge[bend left=1.5cm, above] node{b} (6)
        (1) edge[bend right, below] node{a} (5)
        (2) edge[bend left, above] node{a} (5)
        (1) edge[bend left=2mm, below] node{b} (4)
        (2) edge[bend right=2mm, above] node{b} (4)
        (3) edge[above] node{b} (4)
        (3) edge[loop left] node{a} (3)
        (3) edge[bend left, above] node{a} (5)
        (3) edge[bend right=1.75cm, below] node{b} (6)
        (4) edge[above] node{a} (5)
        (4) edge[bend right, below] node{b} (6)
        (4) edge[loop above] node{b} (4)
        (5) edge[bend right, below] node{b} (6)
        (5) edge[loop above] node{a} (5)
        (6) edge[bend right, above] node{a} (5)
        (6) edge[loop right] node{b} (6);
    \end{tikzpicture}
    \caption{
        Exemple de représentation graphique de l'automate résultant de
        \(glushkov(E(\mathbb{A}))\).
    }\label{fig:automata_glushkov}
\end{figure}

Comme on peut voir sur la figure~\ref{fig:automata_glushkov} les automates
produits sont bien souvent gros et peuvent être dur à comprendre, mais une
machine peut gérer ça très simplement. Outre sa taille, on peut remarquer qu'il
y a des propriétés intéressant sur cette automate. C'est ce que l'on va étudier
maintenant.

\subsubsection*{Propriétés~:}

Nous verrons ici plusieurs propriétés sur les automates de Glushkov, mais nous
n'en ferons pas la preuve, nous en donnerons une justification, mais pas une
réelle preuve.

\vphantom{}

\begin{itemize}[label=\textbullet]
    \item La première propriété plutôt évidente, est que les automates de Glushkov sont
          \textit{standards}, car par constructions, il ne peut avoir qu'un seul état
          initial (0).

          \vphantom{}

    \item La deuxième est que l'automate à \(n + 1\) avec \(n\) le nombre de symboles de
          l'expression régulière. Le \(+ 1\) vient dû fait que nous ajoutons un état
          \(0\) qui a des transitions vers les \(First\).

          \vphantom{}

    \item La troisième propriété un peu moins flagrante est que les automates de Glushkov
          sont accessibles et coaccessibles. C'est dû au fait que chaque symbole dans
          l'expression régulière est accessible et coaccessible et que cette propriété ne
          se perd pas lors de la transformation.

          \vphantom{}

    \item La dernière propriété est que l'automate de Glushkov est homogène. Cela résulte
          de sa construction, car pour qu'un état aille sur un autre état, il faut qu'il
          ait dans ses \textit{Follow} \((a, n)\) avec \(a\) le symbole de la transition
          et \(n\) la valeur de l'état. Et étant donné que pour chaque couple \((b, m)\)
          il ne peut n'avoir que ce couple avec comme seconde valeur \(m\) alors la
          transition vers cet état sera toujours la même.
\end{itemize}

\subsection{Conclusion}

L'algorithme de Glushkov est très puissants, car permet de convertir une
expression régulière en automate ce qui fait qu'on gagne les avantages des deux
structures. Avec les expressions régulières, on peut simplement décrire un
langage et avec les automates, on peut simplement savoir si un mot est reconnu.
Il est très utilisé en \textit{informatique}, parce que pour les humains, il
est plus simple de décrire un langage avec une expression régulière. Et les
machine comprennent très facilement les automates. Ce qui fait qu'il est
possible de faire des \textit{programmes informatiques} qui reconnait un
langage et exécute des tâches à chaque mot.

\end{document}